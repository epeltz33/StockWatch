This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-07T16:40:22.731Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  blueprints/
    auth.py
    main.py
    stock.py
    user.py
  services/
    stock_services.py
    user_services.py
  static/
    css/
      style.css
  templates/
    auth/
      login.html
      register.html
    main/
      dashboard.html
      landing.html
    stocks/
      list.html
    base.html
  __init__.py
  cli.py
  extensions.py
  models.py
frontend/
  assets/
    custom.css
  dashboard.py
migrations/
  versions/
    c2d8899737bc_first_migrate.py
  alembic.ini
  env.py
  README
  script.py.mako
.gitignore
.repomixignore
app.py
config.py
Makefile
Pipfile
README.md
requirements.txt
test_auth.py
update_pipfile.py

================================================================
Repository Files
================================================================

================
File: app/blueprints/auth.py
================
from urllib.parse import urlparse
from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, login_required, current_user
from app.models import User
from app.extensions import db
from werkzeug.security import generate_password_hash, check_password_hash  # noqa: F401

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')


@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')

        user = User.query.filter_by(email=email).first()
        if user:
            flash('Email address already in use.')
            return redirect(url_for('auth.register'))

        new_user = User(username=username, email=email)
        new_user.set_password(password)
        db.session.add(new_user)
        db.session.commit()

        flash('Congratulations, you are now a registered user!')
        return redirect(url_for('auth.login'))

    return render_template('auth/register.html')


@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('main.dashboard'))

    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        user = User.query.filter_by(email=email).first()

        if user and user.check_password(password):
            login_user(user)
            next_page = request.args.get('next')
            if not next_page or urlparse(next_page).netloc != '':
                next_page = url_for('main.dashboard')
            flash('Logged in successfully.', 'success')
            return redirect(next_page)
        else:
            flash('Invalid username or password', 'error')

    return render_template('auth/login.html')


@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'success')
    return redirect(url_for('auth.login'))

================
File: app/blueprints/main.py
================
from flask import Blueprint, render_template, url_for
from flask_login import current_user, login_required
from app import cache


bp = Blueprint('main', __name__)


@bp.route('/')
def landing():
    return render_template('main/landing.html')


@bp.route('/dashboard')
@login_required
def dashboard():
    # Fetch user's stocks from the database or user profile
    # For now,  placeholder list
    user_stocks = ['AAPL', 'GOOGL']  # Replace with actual user stocks later

    user_data = {
        'name': current_user.username,
        'stocks': user_stocks
    }
    cache.set('user_data', user_data)

    dash_url = '/dash/'
    return render_template('main/dashboard.html', dash_url=dash_url, user=current_user)

================
File: app/blueprints/stock.py
================
from flask import Blueprint, render_template, jsonify, request
from app.services import stock_services
from datetime import datetime, timedelta

bp = Blueprint('stock', __name__)


@bp.route('/')
def list_stocks():
    stocks = stock_services.get_all_stocks()
    return render_template('stocks/list.html', stocks=stocks)


@bp.route('/api')
def api_stocks():
    stocks = stock_services.get_all_stocks()
    return jsonify([stock.to_dict() for stock in stocks])


@bp.route('/api/<symbol>')
def stock_info(symbol):
    price = stock_services.get_stock_price(symbol)
    if price is None:
        return jsonify({"error": "Could not fetch stock price. Please try again later."}), 500
    details = stock_services.get_company_details(symbol)
    if not details:
        return jsonify({"error": "Could not fetch company details. Please try again later."}), 500
    return jsonify({
        "symbol": symbol,
        "price": price,
        "details": details
    })


@bp.route('/api/<symbol>/historical')
def stock_historical(symbol):
    days = request.args.get('days', default=30, type=int)
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)
    data = stock_services.get_stock_data(
        symbol, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))
    if not data:
        return jsonify({"error": "Could not fetch historical data. Please try again later."}), 500
    return jsonify(data)

================
File: app/blueprints/user.py
================
from flask import Blueprint, render_template, request, jsonify, abort, redirect, url_for, flash
from app.services import user_services
from flask_login import login_user, logout_user, login_required, current_user

bp = Blueprint('user', __name__, url_prefix='/users')


@bp.route('/')
@login_required
def list_users():
    users = user_services.get_all_users()
    return render_template('users/list.html', users=users)


@bp.route('/<int:user_id>')
@login_required
def user_detail(user_id):
    user = user_services.get_user_by_id(user_id)
    if not user:
        abort(404)
    return render_template('users/detail.html', user=user)


@bp.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        user = user_services.create_user(username, email, password)
        if user:
            flash('Registration successful. Please log in.', 'success')
            # redirect to login not dashboard
            return redirect(url_for('auth.login'))
        else:
            flash('Registration failed. Username may already be in use.', 'error')
    return render_template('users/register.html')


@bp.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = user_services.authenticate_user(username, password)
        if user:
            login_user(user)
            flash('Logged in successfully.', 'success')
            return redirect(url_for('main.index'))
        else:
            flash('Invalid username or password', 'error')
    return render_template('users/login.html')


@bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'success')
    return redirect(url_for('main.index'))


@bp.route('/profile', methods=['GET', 'POST'])
@login_required
def profile():
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        user = user_services.update_user(current_user.id, username, email)
        if user:
            flash('Profile updated successfully.', 'success')
        else:
            flash('Profile update failed.', 'error')
    return render_template('users/profile.html', user=current_user)


@bp.route('/api/users')
@login_required
def api_list_users():
    users = user_services.get_all_users()
    return jsonify([user.to_dict() for user in users])


@bp.route('/api/users/<int:user_id>')
@login_required
def api_user_detail(user_id):
    user = user_services.get_user_by_id(user_id)
    if not user:
        abort(404)
    return jsonify(user.to_dict())


@bp.route('/api/users/<int:user_id>', methods=['DELETE'])
@login_required
def delete_user(user_id):
    if user_services.delete_user(user_id):
        return jsonify({'message': 'User deleted'}), 200
    else:
        return jsonify({'error': 'User not found'}), 404

================
File: app/services/stock_services.py
================
from app.models import Stock
from app import db
from sqlalchemy.exc import IntegrityError
from polygon import RESTClient
from datetime import datetime, timedelta
import pytz
import os

polygon_client = RESTClient(os.getenv('POLYGON_API_KEY'))

# Database-related functions


def get_all_stocks():
    return Stock.query.all()


def get_stock_by_symbol(symbol):
    return Stock.query.filter_by(symbol=symbol).first()


def create_stock(symbol, name):
    stock = Stock(symbol=symbol, name=name)
    db.session.add(stock)
    try:
        db.session.commit()
        return stock
    except IntegrityError:
        db.session.rollback()
        return None


def delete_stock(symbol):
    stock = get_stock_by_symbol(symbol)
    if stock:
        db.session.delete(stock)
        db.session.commit()
        return True
    return False

# Adjusted helper function


def get_most_recent_trading_day():
    now = datetime.now()
    market_close_time = now.replace(
        hour=16, minute=0, second=0, microsecond=0)  # Market close time is 4 PM

    # If it's before market close and today is a weekday, use yesterday's date if the market is closed today, otherwise use today's date
    if now <= market_close_time and now.weekday() < 5:
        most_recent_trading_day = now - \
            timedelta(days=1) if now.weekday() < 5 else now
    else:
        # If it's past market close or a weekend, move to the previous trading day
        if now.weekday() == 5:  # Saturday
            days_to_subtract = 1
        elif now.weekday() == 6:  # Sunday
            days_to_subtract = 2
        else:  # Past market close on a weekday
            days_to_subtract = 1
        most_recent_trading_day = now - timedelta(days=days_to_subtract)

    # Ensure that if today is Monday, we adjust to the previous Friday
    if most_recent_trading_day.weekday() == 5:  # Saturday
        most_recent_trading_day -= timedelta(days=1)
    elif most_recent_trading_day.weekday() == 6:  # Sunday
        most_recent_trading_day -= timedelta(days=2)

    return most_recent_trading_day.strftime('%Y-%m-%d')


# Polygon.io API-related functions


def get_stock_price(symbol):
    try:
        date = get_most_recent_trading_day()
        resp = polygon_client.get_daily_open_close_agg(symbol, date)
        if resp:
            return resp.close  # Use the closing price
    except Exception as e:
        print(f"Error fetching stock price: {e}")
        return None


def get_stock_data(symbol, from_date, to_date):
    try:
        resp = polygon_client.get_aggs(symbol, 1, "day", from_date, to_date)
        if resp and len(resp.results) > 0:
            return [{"date": datetime.fromtimestamp(item.t / 1000).strftime('%Y-%m-%d'),
                     "close": item.c,
                     "volume": item.v} for item in resp.results]
        else:
            return []
    except Exception as e:
        print(f"Error fetching stock data: {e}")
        return []


def get_company_details(symbol):
    try:
        resp = polygon_client.get_ticker_details(symbol)
        return {
            "name": resp.name,
            "market_cap": resp.market_cap,
            "primary_exchange": resp.primary_exchange,
            "description": resp.description
        }
    except Exception as e:
        print(f"Error fetching company details: {e}")
        return {}

================
File: app/services/user_services.py
================
from app.models import User
from app import db
from sqlalchemy.exc import IntegrityError
from werkzeug.security import check_password_hash


def get_all_users():
    return User.query.all()


def get_user_by_id(user_id):
    return User.query.get(user_id)

def get_user_by_email(email):
    return User.query.filter_by(email=email).first()


def get_user_by_username(username):
    return User.query.filter_by(username=username).first()


def create_user(username, email, password):
    user = User(username=username, email=email)
    user.set_password(password)
    db.session.add(user)
    try:
        db.session.commit()
        return user
    except IntegrityError:
        db.session.rollback()
        return None


def update_user(user_id, username=None, email=None):
    user = get_user_by_id(user_id)
    if user:
        if username:
            user.username = username
        if email:
            user.email = email
        try:
            db.session.commit()
            return user
        except IntegrityError:
            db.session.rollback()
            return None
    return None


def delete_user(user_id):
    user = get_user_by_id(user_id)
    if user:
        db.session.delete(user)
        db.session.commit()
        return True
    return False


def authenticate_user(username, password):
    user = get_user_by_username(username)
    if user and check_password_hash(user.password_hash, password):
        return user
    return None

# more user-related services as needed
def verify_password(user, password):
    return check_password_hash(user.password_hash, password)

================
File: app/static/css/style.css
================
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
}

.landing-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  text-align: center;
}

h1 {
  color: #1a73e8;
  font-size: 3rem;
  margin-bottom: 0.5rem;
}

p {
  color: #5f6368;
  font-size: 1.2rem;
  margin-bottom: 2rem;
}

.cta-buttons {
  display: flex;
  gap: 1rem;
}

.btn {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  text-decoration: none;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}

.btn-primary {
  background-color: #1a73e8;
  color: white;
}

.btn-primary:hover {
  background-color: #1557b0;
}

.btn-secondary {
  background-color: #ffffff;
  color: #1a73e8;
  border: 1px solid #1a73e8;
}

.btn-secondary:hover {
  background-color: #e8f0fe;
}

================
File: app/templates/auth/login.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login - StockWatch</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }

    .container {
      max-width: 400px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    h2 {
      text-align: center;
      color: #333;
    }

    form {
      display: flex;
      flex-direction: column;
    }

    label {
      margin-top: 10px;
    }

    input {
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    button {
      margin-top: 20px;
      padding: 10px;
      background-color: #5cb85c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #4cae4c;
    }

    .flashes {
      list-style-type: none;
      padding: 0;
    }

    .flashes li {
      background-color: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }

    .register-link {
      text-align: center;
      margin-top: 15px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Login to StockWatch</h2>

    {% with messages = get_flashed_messages() %}
    {% if messages %}
    <ul class="flashes">
      {% for message in messages %}
      <li>{{ message }}</li>
      {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}

    <form method="POST">
      <label for="email">Email:</label>
      <input type="email" name="email" required>

      <label for="password">Password:</label>
      <input type="password" name="password" required>

      <button type="submit">Login</button>
    </form>

    <div class="register-link">
      <p>Don't have an account? <a href="{{ url_for('auth.register') }}">Register here</a></p>
    </div>
  </div>
</body>

</html>

================
File: app/templates/auth/register.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Register - StockWatch</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }

    .container {
      max-width: 400px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    h2 {
      text-align: center;
      color: #333;
    }

    form {
      display: flex;
      flex-direction: column;
    }

    label {
      margin-top: 10px;
    }

    input {
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    button {
      margin-top: 20px;
      padding: 10px;
      background-color: #5cb85c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #4cae4c;
    }

    .flashes {
      list-style-type: none;
      padding: 0;
    }

    .flashes li {
      background-color: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Register for StockWatch</h2>

    {% with messages = get_flashed_messages() %}
    {% if messages %}
    <ul class="flashes">
      {% for message in messages %}
      <li>{{ message }}</li>
      {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}

    <form method="POST">
      <label for="username">Username:</label>
      <input type="text" name="username" required>

      <label for="email">Email:</label>
      <input type="email" name="email" required>

      <label for="password">Password:</label>
      <input type="password" name="password" required>

      <button type="submit">Register</button>
    </form>
  </div>
</body>

</html>

================
File: app/templates/main/dashboard.html
================
{% extends "base.html" %}

{% block title %}Dashboard - StockWatch{% endblock %}

{% block content %}
<div class="container mt-4">
  <h1 class="mb-4">Welcome to Your StockWatch Dashboard, {{user.username}}</h1>

  <div class="row">
    <div class="col-md-12">
      <!-- This is where the Dash app will be rendered -->
      <div id="dash-container">
        <iframe src="{{ dash_url }}" width="100%" height="800px"></iframe>
      </div>
    </div>
  </div>

  <div class="row mt-4">
    <div class="col-md-4">
      <div class="card mb-4">
        <div class="card-header">
          Quick Actions
        </div>
        <div class="card-body">
          <a href="{{ url_for('auth.logout') }}" class="btn btn-danger btn-block">Logout</a>
        </div>
      </div>
      <div class="card">
        <div class="card-header">
          Recent Activity
        </div>
        <div class="card-body">
          <!-- This will be populated with real data in the future -->
          <p>Your recent activity will be shown here.</p>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ dash_url }}dash-renderer"></script>
<script id="_dash-config" type="application/json">
  {
    "url_base_pathname": "{{ dash_url }}"
  }
</script>
{% endblock %}

================
File: app/templates/main/landing.html
================
{% extends "base.html" %}

{% block content %}
<div class="landing-container">
  <h1>Welcome to StockWatch</h1>
  <p>Your personal stock tracking assistant</p>
  <div class="cta-buttons">
    <a href="{{ url_for('auth.login') }}" class="btn btn-primary">Login</a>
    <a href="{{ url_for('auth.register') }}" class="btn btn-secondary">Register</a>
  </div>
</div>
{% endblock %}

================
File: app/templates/stocks/list.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock List</title>
</head>

<body>
  <h1>Stock List</h1>
  <p>Welcome to the stock list page. You are successfully logged in!</p>
</body>

</html>

================
File: app/templates/base.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% block title %}StockWatch{% endblock %}</title>
  <!-- Add your CSS links here -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
  <!-- If using Bootstrap -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
</head>

<body>
  <header>
    <!-- Add navigation bar here -->
  </header>

  <!-- Add section for flash messages -->
  <div class="container">
    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    {% for category, message in messages %}
    <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
      {{ message }}
      <button type="button" class="close" data-dismiss="alert" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </button>
    </div>
    {% endfor %}
    {% endif %}
    {% endwith %}
  </div>

  <main>
    {% block content %}
    {% endblock %}
  </main>

  <footer>
    <!-- Add footer content here -->
  </footer>

  <!--   JavaScript links here -->
  <script src="{{ url_for('static', filename='js/main.js') }}"></script>
  <!--  Bootstrap -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.3/dist/umd/popper.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>

</html>

================
File: app/__init__.py
================
from flask import Flask, redirect, url_for
from flask_caching import Cache
from config import Config
from app.extensions import db, migrate, login
from app.models import User
import os
from dotenv import load_dotenv

load_dotenv()

cache = Cache()


def create_app(test_config=None):
    app = Flask(__name__, template_folder='templates', static_folder='static')

    if test_config is None:
        app.config.from_object(Config)
    else:
        app.config.from_mapping(test_config)

    app.config['SECRET_KEY'] = os.environ.get(
        'SECRET_KEY', 'fallback_secret_key')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)
    migrate.init_app(app, db)
    login.init_app(app)
    cache.init_app(app)

    login.login_view = 'auth.login'

    @login.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))

    from app.blueprints.auth import auth_bp
    app.register_blueprint(auth_bp)

    from app.blueprints.stock import bp as stock_bp
    app.register_blueprint(stock_bp, url_prefix='/stock')

    from app.blueprints.user import bp as user_bp
    app.register_blueprint(user_bp, url_prefix='/user')

    from app.blueprints.main import bp as main_bp
    app.register_blueprint(main_bp)

    @app.route('/')
    def index():
        return redirect(url_for('main.landing'))

    from app.cli import delete_user
    app.cli.add_command(delete_user)

    # Import create_dash_app outside of app_context
    from frontend.dashboard import create_dash_app

    with app.app_context():
        # Create Dash app within app_context
        create_dash_app(app)

    return app

================
File: app/cli.py
================
from flask.cli import with_appcontext
import click
from app.models import User, Watchlist
from app.extensions import db


@click.command('delete-user')
@click.argument('email')
@with_appcontext
def delete_user(email):
    user = User.query.filter_by(email=email).first()
    if user:
        # Delete associated watchlists (which will cascade to stocks)
        Watchlist.query.filter_by(user_id=user.id).delete()

        db.session.delete(user)
        db.session.commit()
        click.echo(f"User with email {
                   email} and all associated data has been deleted")
    else:
        click.echo(f"No user found with email {email}")

================
File: app/extensions.py
================
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager  # type: ignore

db = SQLAlchemy()
migrate = Migrate()
login = LoginManager()
login.login_view = 'auth.login'

================
File: app/models.py
================
from app.extensions import db
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash


class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    # Increase the length of the password hash
    password_hash = db.Column(db.String(256))
    watchlists = db.relationship(
        'Watchlist', backref='user', lazy='dynamic', cascade='all, delete-orphan')

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


class Watchlist(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    stocks = db.relationship('Stock', secondary='watchlist_stocks',
                             cascade='all, delete-orphan', single_parent=True)

    def __init__(self, name, user_id):
        self.name = name
        self.user_id = user_id


class Stock(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    symbol = db.Column(db.String(10), unique=True, nullable=False)
    name = db.Column(db.String(100))

    def __init__(self, symbol, name):
        self.symbol = symbol
        self.name = name


watchlist_stocks = db.Table('watchlist_stocks',
                            db.Column('watchlist_id', db.Integer, db.ForeignKey(
                                'watchlist.id', ondelete='CASCADE'), primary_key=True),
                            db.Column('stock_id', db.Integer, db.ForeignKey(
                                'stock.id', ondelete='CASCADE'), primary_key=True)
                            )

================
File: frontend/assets/custom.css
================
/* Reset and base styles */
body {
    background-color: #f9f9f9;
    font-family: 'Roboto', sans-serif;
    color: #2c3e50;
    line-height: 1.6;
}

.container-fluid {
    max-width: 1400px;
    margin: 0 auto;
    padding: 30px 15px;
}

/* Typography */
h2, h3 {
    color: #2c3e50;
    margin-bottom: 1rem;
}

h2 {
    font-size: 2.5rem;
    font-weight: 700;
}

h3 {
    font-size: 2rem;
    font-weight: 600;
}

/* Card styles */
.card {
    background-color: #ffffff;
    border: none;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    margin-bottom: 20px;
}

.card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.card-header {
    background-color: #3498db;
    color: white;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    padding: 15px 20px;
}

.card-body {
    padding: 20px;
}

/* Button styles */
.btn-primary {
    background-color: #3498db;
    border-color: #3498db;
    transition: all 0.3s ease;
}

.btn-primary:hover {
    background-color: #2980b9;
    border-color: #2980b9;
}

/* Form control styles */
.form-control {
    border-radius: 5px;
    border: 1px solid #bdc3c7;
}

.form-control:focus {
    border-color: #3498db;
    box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25);
}

/* Stock dashboard */
.stock-dashboard {
    background-color: #ffffff;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 30px;
    margin-bottom: 30px;
}

/* Stock chart */
#stock-chart {
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    background-color: #ffffff;
}

/* Watchlist section */
#watchlist-section {
    background-color: #ffffff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* List group items */
.list-group-item {
    border: none;
    border-bottom: 1px solid #ecf0f1;
    transition: background-color 0.3s ease;
}

.list-group-item:last-child {
    border-bottom: none;
}

.list-group-item:hover {
    background-color: #f4f6f7;
}

/* Responsive design */
@media (max-width: 768px) {
    .container-fluid {
        padding: 15px;
    }

    h2 {
        font-size: 2rem;
    }

    h3 {
        font-size: 1.75rem;
    }

    .card-body {
        padding: 15px;
    }
}

================
File: frontend/dashboard.py
================
import dash
from dash import html, dcc, Input, Output, State, callback_context, no_update, ALL
import dash_bootstrap_components as dbc
import plotly.graph_objs as go
from polygon import RESTClient
from datetime import datetime, timedelta
import pandas as pd
import os
from app import db
from flask_login import current_user
from app.models import Watchlist, Stock
from sqlalchemy.exc import SQLAlchemyError
import logging
import json
from dash import dash_table







# Define color scheme (using values from custom.css)
COLORS = {
    'primary': '#3498db',
    'secondary': '#ecf0f1',
    'text': '#2c3e50',
    'positive': '#2ecc71',
    'negative': '#e74c3c',
    'background': '#f9f9f9',
    'card': '#ffffff'
}

# Define custom styles (integrating with custom.css)
CUSTOM_STYLES = {
    'card': {
        'borderRadius': '10px',
        'marginBottom': '20px',
        'transition': 'all 0.3s ease'
    },
    'button': {
        'borderRadius': '5px',
        'transition': 'all 0.3s ease'
    }
}

def create_stock_card(title, value, change):
    return dbc.Card([
        dbc.CardBody([
            html.H4(title, className="card-title"),
            html.H2(value, className="mb-2"),
            html.P(change, className=f"{'text-success' if float(change.strip('%')) > 0 else 'text-danger'}")
        ])
    ], className='card')  # Using the 'card' class from custom.css

def create_watchlist_table(data):
    return dash_table.DataTable(
        data=data,
        columns=[
            {"name": "Symbol", "id": "symbol"},
            {"name": "Company", "id": "company"},
            {"name": "Price", "id": "price"},
            {"name": "Change", "id": "change"}
        ],
        style_cell={'textAlign': 'left'},
        style_data_conditional=[
            {
                'if': {'column_id': 'change', 'filter_query': '{change} > 0'},
                'color': COLORS['positive']
            },
            {
                'if': {'column_id': 'change', 'filter_query': '{change} < 0'},
                'color': COLORS['negative']
            }
        ],
        style_header={
            'backgroundColor': COLORS['secondary'],
            'fontWeight': 'bold'
        },
        style_table={'overflowX': 'auto'}
    )



# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Polygon client
polygon_api_key = os.getenv('POLYGON_API_KEY')
client = RESTClient(api_key=polygon_api_key)

def create_dash_app(flask_app):
    dash_app = dash.Dash(__name__, server=flask_app, url_base_pathname='/dash/',
                        external_stylesheets=[dbc.themes.BOOTSTRAP, '/assets/custom.css'],
                        assets_folder='assets')

    dash_app.layout = create_layout()

    register_callbacks(dash_app)

    return dash_app

def create_layout():
    return dbc.Container([
        dbc.Row([
            dbc.Col([
                html.Div([
                    html.H2(id='welcome-message', className='text-center mb-3'),
                    html.H3('Your Stock Dashboard', className='text-center mb-4')
                ], className='stock-dashboard')
            ], width=12)
        ]),
        dbc.Row([
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        dbc.InputGroup([
                            dbc.Input(id='stock-input', type='text', placeholder='Enter a stock ticker...'),
                            dbc.InputGroupText(dbc.Button('Search', id='search-button', color='primary'))
                        ], className='mb-3'),
                        html.Div(id='stock-data')
                    ])
                ], className='mb-4'),
                html.Div(id='watchlist-section', children=[
                    dcc.Dropdown(id='watchlist-dropdown', options=[], placeholder='Select a watchlist', className='mb-2'),
                    dbc.Input(id='new-watchlist-input', type='text', placeholder='Enter a new watchlist name...', className='mb-2'),
                    dbc.Button('Create Watchlist', id='create-watchlist-button', color='primary', className='mb-3')
                ])
            ], md=4, className='mb-4'),
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        dcc.Graph(id='stock-chart')
                    ])
                ])
            ], md=8)
        ]),
        dcc.Interval(id='watchlist-interval', interval=5*1000, n_intervals=0)
    ], fluid=True, className='py-4')

def register_callbacks(dash_app):


    @dash_app.callback(Output('watchlist-dropdown', 'options'),
                    Input('watchlist-interval', 'n_intervals'))
    def update_watchlist_dropdown(n_intervals):
        if current_user.is_authenticated:
            watchlists = current_user.watchlists.all()
            return [{'label': w.name, 'value': w.id} for w in watchlists]
        return []

    @dash_app.callback(
        [Output('watchlist-section', 'children'),
         Output('watchlist-dropdown', 'value'),
         Output({'type': 'add-to-watchlist', 'index': ALL}, 'children')],
        [Input('create-watchlist-button', 'n_clicks'),
         Input({'type': 'add-to-watchlist', 'index': ALL}, 'n_clicks'),
         Input({'type': 'remove-from-watchlist', 'index': ALL}, 'n_clicks'),
         Input('watchlist-dropdown', 'value')],
        [State('new-watchlist-input', 'value'),
         State('watchlist-dropdown', 'value'),
         State({'type': 'add-to-watchlist', 'index': ALL}, 'id')]
    )
    def update_watchlist(create_clicks, add_clicks, remove_clicks, selected_watchlist_id, new_watchlist_name, current_watchlist_id, add_ids):
        ctx = callback_context
        if not ctx.triggered:
            return no_update, no_update, [no_update] * len(add_ids)

        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

        if trigger_id == 'create-watchlist-button' and new_watchlist_name:
            return create_new_watchlist(new_watchlist_name, add_ids)
        elif 'add-to-watchlist' in trigger_id:
            button_id = json.loads(trigger_id)
            if add_clicks is not None and any(click is not None and click > 0 for click in add_clicks):
                return add_stock_to_watchlist(button_id, current_watchlist_id, add_ids)
        elif 'remove-from-watchlist' in trigger_id:
            button_id = json.loads(trigger_id)
            return remove_stock_from_watchlist(button_id, current_watchlist_id, add_ids)
        elif trigger_id == 'watchlist-dropdown':
            return update_watchlist_section(selected_watchlist_id), selected_watchlist_id, [no_update] * len(add_ids)

        return no_update, no_update, [no_update] * len(add_ids)

    @dash_app.callback(
        [Output('stock-data', 'children'),
         Output('stock-chart', 'figure'),
         Output('stock-input', 'value')],
        [Input({'type': 'watchlist-stock', 'index': ALL}, 'n_clicks'),
         Input('search-button', 'n_clicks')],
        [State({'type': 'watchlist-stock', 'index': ALL}, 'id'),
         State('stock-input', 'value')]
    )
    def update_stock_data(watchlist_clicks, search_clicks, watchlist_stock_ids, search_input):
        ctx = callback_context
        if not ctx.triggered:
            return no_update, no_update, no_update

        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

        if 'watchlist-stock' in trigger_id:
            clicked_stock = json.loads(trigger_id)['index']
        elif trigger_id == 'search-button':
            clicked_stock = search_input
        else:
            return no_update, no_update, no_update

        if not clicked_stock:
            return html.Div("Enter a stock ticker and click 'Search'"), go.Figure(), no_update

        stock_info, chart = fetch_and_display_stock_data(clicked_stock)
        return stock_info, chart, clicked_stock



def create_new_watchlist(new_watchlist_name, add_ids):
    try:
        watchlist = Watchlist(name=new_watchlist_name, user_id=current_user.id)
        db.session.add(watchlist)
        db.session.commit()
        return update_watchlist_section(watchlist.id), watchlist.id, [no_update] * len(add_ids)
    except SQLAlchemyError as e:
        logger.error(f"Error creating watchlist: {str(e)}")
        return no_update, no_update, [no_update] * len(add_ids)

def add_stock_to_watchlist(button_id, watchlist_id, add_ids):
    stock_symbol = button_id['index']
    logger.info(f"Adding stock {stock_symbol} to watchlist {watchlist_id}")
    try:
        stock = Stock.query.filter_by(symbol=stock_symbol).first()
        if not stock:
            stock = create_new_stock(stock_symbol)

        watchlist = Watchlist.query.get(watchlist_id)
        if watchlist and stock not in watchlist.stocks:
            watchlist.stocks.append(stock)
            db.session.commit()
        updated_add_ids = ['Added' if id['index'] == stock_symbol else no_update for id in add_ids]
        return update_watchlist_section(watchlist_id), watchlist_id, updated_add_ids
    except Exception as e:
        logger.error(f"Error adding stock to watchlist: {str(e)}")
        return no_update, no_update, [no_update] * len(add_ids)

def remove_stock_from_watchlist(button_id, watchlist_id, add_ids):
    stock_id = button_id['index']
    try:
        stock = Stock.query.get(stock_id)
        watchlist = Watchlist.query.get(watchlist_id)
        if watchlist and stock in watchlist.stocks:
            watchlist.stocks.remove(stock)
            db.session.commit()
        return update_watchlist_section(watchlist_id), watchlist_id, [no_update] * len(add_ids)
    except Exception as e:
        logger.error(f"Error removing stock from watchlist: {str(e)}")
        return no_update, no_update, [no_update] * len(add_ids)

def create_new_stock(stock_symbol):
    try:
        logger.info(f"Creating new stock: {stock_symbol}")
        stock_details = client.get_ticker_details(stock_symbol)
        stock_name = stock_details.name if hasattr(stock_details, 'name') else stock_symbol
        stock = Stock(symbol=stock_symbol, name=stock_name)
        db.session.add(stock)
        db.session.commit()
        logger.info(f"Stock created: {stock_symbol} - {stock_name}")
        return stock
    except Exception as e:
        logger.error(f"Error creating stock: {stock_symbol} - {str(e)}")
        raise

def update_watchlist_section(watchlist_id):
    if not current_user.is_authenticated:
        return html.P("Please log in to view your watchlists.")

    watchlists = current_user.watchlists.all()
    if not watchlists:
        return create_empty_watchlist_section()

    watchlist_options = [{'label': w.name, 'value': w.id} for w in watchlists]
    watchlist_dropdown = dcc.Dropdown(
        id='watchlist-dropdown',
        options=watchlist_options,
        value=watchlist_id,
        className='mb-2'
    )
    create_watchlist_input = dbc.Input(
        id='new-watchlist-input',
        type='text',
        placeholder='Enter a new watchlist name...',
        className='mb-2'
    )
    create_watchlist_button = dbc.Button(
        'Create Watchlist',
        id='create-watchlist-button',
        color='primary',
        className='mb-4'
    )

    if watchlist_id:
        watchlist = Watchlist.query.get(watchlist_id)
        if watchlist:
            watchlist_content = create_watchlist_content(watchlist)
            print(watchlist_content)
        else:
            watchlist_content = html.P("Select a watchlist to view stocks or create a new watchlist.")
    else:
        watchlist_content = html.P("Select a watchlist to view stocks or create a new watchlist.")

    return html.Div([
        watchlist_dropdown,
        create_watchlist_input,
        create_watchlist_button,
        watchlist_content
    ])

def create_empty_watchlist_section():
    return html.Div([
        html.H4("You don't have any watchlists yet."),
        dbc.Input(id='new-watchlist-input', type='text',
                  placeholder='Enter a new watchlist name...', className='mb-2'),
        dbc.Button('Create Watchlist', id='create-watchlist-button',
                   color='primary', className='mb-4')
    ])

def create_watchlist_content(watchlist):
    return dbc.Card([
        dbc.CardHeader(
            html.H4(watchlist.name, className="text-center")),
        dbc.CardBody([
            dbc.ListGroup([
                dbc.ListGroupItem([
                    dbc.Row([
                        dbc.Col(
                            html.A(
                                [
                                    html.Span(stock.symbol, className="font-weight-bold me-2"),
                                    html.Span(stock.name)
                                ],
                                href="#",
                                id={'type': 'watchlist-stock', 'index': stock.symbol},
                                className="text-decoration-none text-reset"
                            ),
                            width=10
                        ),
                        dbc.Col(
                            dbc.Button(
                                "Remove",
                                color="danger",
                                size="sm",
                                className="float-right",
                                id={'type': 'remove-from-watchlist', 'index': stock.id}
                            ),
                            width=2
                        )
                    ], className="align-items-center")
                ], className="py-2")
                for stock in watchlist.stocks
            ], flush=True)
        ])
    ], className="mb-4")

def fetch_and_display_stock_data(ticker):
    try:
        details = client.get_ticker_details(ticker)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)
        aggs = client.get_aggs(ticker, 1, "day", start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d"))

        if not aggs:
            return html.Div(f"No data available for {ticker}"), go.Figure()

        df = pd.DataFrame(aggs)
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

        # calc avg volume
        avg_volume = df['volume'].mean()

        #Calc percent change
        latest_close = df.iloc[-1]['close']
        previous_close = df.iloc[-2]['close']
        percent_change = ((latest_close - previous_close) / previous_close) * 100

        stock_info = create_stock_info_card(details, df, ticker, avg_volume, percent_change)
        fig = create_stock_chart(df, ticker)

        return stock_info, fig

    except Exception as e:
        logger.error(f"Error fetching stock data for {ticker}: {str(e)}")
        return html.Div(f"An error occurred: {str(e)}"), go.Figure()

def create_stock_info_card(details, df, ticker, avg_volume, percent_change):
    week_52_high = df['high'].max()
    week_52_low = df['low'].min()
    latest_day = df.iloc[-1]
    previous_day = df.iloc[-2]

    name = getattr(details, 'name', ticker)
    description = getattr(details, 'description', 'No description available')
    market_cap = getattr(details, 'market_cap', 'N/A')
    logo_url = getattr(details.branding, 'logo_url', '') if hasattr(details, 'branding') else ''

    if logo_url:
        logo_url = f"{logo_url}?apiKey={polygon_api_key}"

    # Determine color for % change
    color = 'green' if percent_change >= 0 else 'red'

    return dbc.Card([
        dbc.CardBody([
            html.Img(src=logo_url, alt=f"{name} logo", style={
                    'max-width': '100%', 'height': 'auto', 'max-height': '50px', 'marginBottom': '10px'}) if logo_url else None,
            html.H4(f"{name} ({ticker})", className='card-title'),
            html.Hr(),
            html.P([
                f"Current Price: ${latest_day['close']:.2f} ",
                html.Span(f"({percent_change:.2f}%)", style={'color': color})
            ], className='card-text font-weight-bold'),
            html.P(f"Previous Close: ${previous_day['close']:.2f}", className='card-text'),
            html.P(f"Open: ${latest_day['open']:.2f}", className='card-text'),
            html.P(f"52 Week Range: ${week_52_low:.2f} - ${week_52_high:.2f}", className='card-text'),
            html.P(f"Volume: {latest_day['volume']:,}", className='card-text'),
            html.P(f"Average Volume: {avg_volume:,.0f}", className='card-text'),
            html.P(f"Market Cap: ${market_cap:,}" if isinstance(
                market_cap, (int, float)) else f"Market Cap: {market_cap}", className='card-text'),
            html.P(description, className='card-text mt-3'),
            html.Hr(),
            dbc.Button('Add to Watchlist', id={
                       'type': 'add-to-watchlist', 'index': ticker}, color='success', className='mt-2')
        ])
    ])
def create_stock_chart(df, ticker):
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=df['timestamp'], y=df['close'], mode='lines', name='Close Price'))
    fig.update_layout(title=f"{ticker} Stock Price",
                      xaxis_title='Date', yaxis_title='Price', height=600)
    return fig

================
File: migrations/versions/c2d8899737bc_first_migrate.py
================
"""first migrate

Revision ID: c2d8899737bc
Revises: 
Create Date: 2024-11-28 21:40:20.001011

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'c2d8899737bc'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('stock',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('symbol', sa.String(length=10), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('symbol')
    )
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=64), nullable=True),
    sa.Column('email', sa.String(length=120), nullable=True),
    sa.Column('password_hash', sa.String(length=256), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_user_email'), ['email'], unique=True)
        batch_op.create_index(batch_op.f('ix_user_username'), ['username'], unique=True)

    op.create_table('watchlist',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=64), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('watchlist_stocks',
    sa.Column('watchlist_id', sa.Integer(), nullable=False),
    sa.Column('stock_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['stock_id'], ['stock.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['watchlist_id'], ['watchlist.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('watchlist_id', 'stock_id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('watchlist_stocks')
    op.drop_table('watchlist')
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_user_username'))
        batch_op.drop_index(batch_op.f('ix_user_email'))

    op.drop_table('user')
    op.drop_table('stock')
    # ### end Alembic commands ###

================
File: migrations/alembic.ini
================
# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

================
File: migrations/env.py
================
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

================
File: migrations/README
================
Single-database configuration for Flask.

================
File: migrations/script.py.mako
================
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
*.pyc

# C extensions
*.so

# Distribution / packaging
.Python
env/
venv/
ENV/
env.bak/
venv.bak/
*.egg-info/
.installed.cfg
*.egg
dist/
build/
*.pyo
*.pyd

# Flask specific
instance/
*.db
*.sqlite3
__pycache__/

# VS Code
.vscode/

# PyCharm specific
.idea/

# DataGrip specific
.idea/

# Environments
.env
*.env

# Node specific
node_modules/
npm-debug.log

# Sphinx documentation
docs/_build/

# Jupyter Notebook
.ipynb_checkpoints

# pytest
.cache

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# AWS specific
*.pem

# Logs and databases
*.log
*.sql
*.sqlite

# OS generated files
.DS_Store
Thumbs.db.env
app/__pycache__.env

================
File: .repomixignore
================
.devcontainer
.vscode
node_modules
pickler.py
tickers.csv

================
File: app.py
================
from models import User
from dotenv import load_dotenv
import os
from flask import Flask, redirect
from flask_login import LoginManager
from flask_sqlalchemy import SQLAlchemy
from dashboard import create_dash_app
import logging


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

load_dotenv()

db = SQLAlchemy()
login_manager = LoginManager()


def create_app():
    app = Flask(__name__)
    app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'a_default_secret_key')
    app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv(
        'DATABASE_URL', 'sqlite:///your_database.db')
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)
    login_manager.init_app(app)

    from auth.routes import auth_bp
    from main.routes import main_bp
    app.register_blueprint(auth_bp)
    app.register_blueprint(main_bp)

    @app.route('/')
    def index():
        return redirect('/dash/')

    with app.app_context():
        db.create_all()
        create_dash_app(app)

    return app


app = create_app()


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

================
File: config.py
================
import os
from dotenv import load_dotenv

basedir = os.path.abspath(os.path.dirname(__file__))
load_dotenv()


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'fallback-secret-key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    # Cache configuration
    CACHE_TYPE = "SimpleCache"
    CACHE_DEFAULT_TIMEOUT = 300  # 5 minutes

================
File: Makefile
================
.PHONY: run db-init db-migrate db-upgrade

run:
	python dev_server.py

test:
	pytest tests/

test-stock-routes:
	python -m unittest tests/test_stock_routes.py

db-init:
	flask db init

db-migrate:
	flask db migrate -m "Migration"

db-upgrade:
	flask db upgrade

setup-db: db-init db-migrate db-upgrade

all: setup-db run

================
File: Pipfile
================
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
pyt = "*"
flask = "*"
flask-sqlalchemy = "*"
flask-migrate = "*"
flask-wtf = "*"
flask-login = "*"
requests = "*"
plotly = "*"
dash = "*"
dash-bootstrap-components = "*"
polygon-api-client = "*"
stockstats = "*"
pandas = "*"
numpy = "*"
requests-html = "*"
flask-caching = "*"
dash-table = "*"
dash-html-components = "*"
dash-daq = "*"
celery = "*"
redis = "*"
toml = "*"
python-dotenv = {extras = ["cli"], version = "*"}

[dev-packages]
pytest = "*"
ipykernel = "*"

[requires]
python_version = "3.12"

================
File: README.md
================
---

# 📈 StockWatch

## Overview

The **StockWatch App** is a web-based application designed to help users monitor and manage their stock portfolios. Built with **Flask** for the backend and **Plotly Dash** for the frontend, this app allows users to track their favorite stocks, view historical data, and maintain a personalized watchlist.

## Features

- 🔐 **User Authentication**: Secure registration and login functionalities.
- 📊 **Stock Data Integration**: Fetch delayed stock data using the Polygon.io API.
- 📈 **Watchlist Management**: Add, view, and remove stocks from your personalized watchlist.
- 📉 **Data Visualization**: Interactive charts and graphs to visualize stock performance.
- 📱 **Responsive Design**: Accessible on desktop.

## Technology Stack

- **Backend**: Flask, SQLAlchemy
- **Frontend**: Plotly Dash, Dash Bootstrap Components, CSS
- **Database**: SQLite
- **API**: Polygon.io
- **Development Tools**: VScode, Codespaces, GitHub
- **Deployment**: tbd

## Installation

### Prerequisites

- Python 3.12
- Pipenv
  

### Steps

1. **Clone the Repository**:
   ```bash
   git clone https://github.com/yourusername/stock-tracker-app.git
   cd stock-tracker-app
   ```

2. **Set Up Virtual Environment**:
   ```bash
   pipenv --python 3.12
   pipenv install
   ```

3. **Set Up Environment Variables**:
   Create a `.env` file in the root directory and add your configuration:
   ```plaintext
   SECRET_KEY=your_secret_key
   DATABASE_URL=mysql://username:password@localhost/dbname
   POLYGON_API_KEY=your_polygon_api_key
   ```

4. **Initialize the Database**:
   ```bash
   pipenv run flask db upgrade
   ```

5. **Run the Application**:
   ```bash
   pipenv run flask run
   ```
   

## Usage

1. **Register and Login**:
   - Navigate to the registration page to create an account.
   - Use your credentials to log in.

2. **Search for Stocks**:
   - Use the search functionality to find stocks and view their data.

3. **Add to Watchlist**:
   - Add stocks to your watchlist for easy tracking.

4. **View Data**:
   - Access historical data visualized through interactive charts.
     


## Contact

For questions or feedback, please contact [erpeltz@gmail.com](mailto:erpeltz@gmail.com).

---

================
File: requirements.txt
================
pyt

================
File: test_auth.py
================
import unittest
from flask import url_for
from app import create_app, db
from app.models import User


class AuthTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app({
            'TESTING': True,
            'WTF_CSRF_ENABLED': False,
            'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
            'SECRET_KEY': 'test_secret_key'
        })
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()
        self.client = self.app.test_client()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def test_register_and_login(self):
        # Test registration
        response = self.client.post('/auth/register', data={
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(
            b'Congratulations, you are now a registered user!', response.data)

        # Test login
        response = self.client.post('/auth/login', data={
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Logged in successfully.', response.data)

        # Test accessing a protected page
        response = self.client.get('/dashboard', follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Welcome to Your StockWatch Dashboard', response.data)

    def test_logout(self):
        # Register a user
        self.client.post('/auth/register', data={
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)

        # Login
        self.client.post('/auth/login', data={
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)

        # Test logout
        response = self.client.get('/auth/logout', follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'You have been logged out.', response.data)

        # Verify that accessing a protected page redirects to login
        response = self.client.get('/dashboard', follow_redirects=True)
        self.assertIn(b'Please log in to access this page', response.data)

    def test_login_with_incorrect_password(self):
        # Register a user
        self.client.post('/auth/register', data={
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)

        # Attempt to login with incorrect password
        response = self.client.post('/auth/login', data={
            'email': 'test@example.com',
            'password': 'wrongpassword'
        }, follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Invalid username or password', response.data)

    def test_register_existing_user(self):
        # Register a user
        self.client.post('/auth/register', data={
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)

        # Attempt to register the same user again
        response = self.client.post('/auth/register', data={
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'password'
        }, follow_redirects=True)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Email address already in use', response.data)


if __name__ == '__main__':
    unittest.main()

================
File: update_pipfile.py
================
import json
import toml

# Read Pipfile.lock
with open('Pipfile.lock') as f:
    lock_data = json.load(f)

# Read Pipfile
with open('Pipfile') as f:
    pipfile_data = toml.load(f)

# Update versions in Pipfile data
for section in ['default', 'develop']:
    if section in lock_data:
        for package, info in lock_data[section].items():
            if package in pipfile_data['packages']:
                pipfile_data['packages'][package] = f"=={info['version']}"
            elif section == 'develop' and package in pipfile_data.get('dev-packages', {}):
                pipfile_data['dev-packages'][package] = f"=={info['version']}"

# Write updated Pipfile
with open('Pipfile', 'w') as f:
    toml.dump(pipfile_data, f)

print("Pipfile updated with exact versions from Pipfile.lock")
